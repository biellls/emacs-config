;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(map + [0 0] [1 0])" "(neighbors 3 [0 0])" "(neighbors [0 0])" "(problem12)" "(nth (n-queens-problem 10) 1)" "(nth (n-queens-problem 10) 0)" "(nth (n-queens-problem 10) 10)" "(nth (n-queens-problem 8) 10)" "(n-queens-problem 8)" "(n-queens-problem 7)" "(n-queens-problem 6)" "(n-queens-problem 5)" "(n-queens-problem 4)" "(n-queens-problem 3)" "(n-queens-problem 1)" "(n-queens-problem 2)" "(sieve 1000000)" "(nth (lazyprimes 100) 10)" "(nth (lazyprimes 100) 1)" "(nth (lazyprimes 100) 0)" "(nth (lazyprimes 100) 3)" "(class (lazyprimes 100))" "(lazyprimes 13195)" "(take-while (partial > 30) (lazyprimes 200))" "(problem6 13195)" "(factor? 12 2)" "(factor? 12 12)" "(factor? 2 12)" "(last (lazyprimes 600851475143))" "(class (inc' 2))" "(inc' 2)" "(class (*' 2 3))" "(class (inc 0.3))" "(inc 0.3)" "(inc .3)" "(last (lazyprimes 600851475143))" "(take 13 (lazyprimes 32))" "(take 11 (lazyprimes 32))" "(take 10 (lazyprimes 32))" "(take 10 (lazyprimes 30))" "(take 10 (lazyprimes bss))" "bss" "(def bss (sieve 200))" "(seq bss)" "(time (do (sieve 100000) nil))" "(time (do (sieve 10000) nil))" "(sieve 100)" "(sieve 20)" "bss" "(bsremove-multiples bss 2 5)" "bss" "(bsremove-multiples bss 2 5)" "bss" "(bsremove-multiples bss 2 30)" "(bsremove-multiples bss 2 5)" "bss" "(bsremove bss 0)" "(bsremove bs 0)" "bss" "(bsremove-multiples bss 2)" "(bsremove-multiples bs 2)" "bss" "(def bss (makebs 5))" "bss" "(def bss (makebs 5))" "bss" "(.set bss 0 3)" "bss" "(def bss (makebs 5))" "(in-ns 'clojure-noob.primes)" "(in-ns clojure-noob.primes)" "(def bss (makebs 5))" "(sieve 10)" "(rest (range 2 11 2))" "(range 2 11 2)" "(.get bbs 9)" "(.get bbs 5)" "(.get bbs 4)" "(.get bbs 3)" "(.get bbs 2)" "(.get bbs 0)" "bbs" "(def bbs (sieve 5))" "(def bbs (sieve))" "(sieve 2)" "(problem5)" "(evenly-divisible? 4 12)" "(evenly-divisible? 3 12)" "(evenly-divisible? 4 12)" "(problem5)" "(evenly-divisible? 2500 10)" "(evenly-divisible? 2520 10)" "(evenly-divisible? 2500 10)" "(take-nth 2 (range 1 100))" "(take-nth 3 (range 1 100))" "(time (do (first-n-primes 1e6) nil))" "(nth (sieve (iterate inc 2)) 2100)" "(nth 2100 (sieve (iterate inc 2)))" "(take 2100 (sieve (iterate inc 2)))" "(take 100 (sieve (iterate inc 2)))" "(time (do (take 1000 prime-numbers) nil))" "(time (do (take 1000 (sieve (iterate inc 2))) nil))" "(time (take 1000 (sieve (iterate inc 2))))" "(time (take 100 prime-numbers))" "(time (take 100 (sieve (iterate inc 2))))" "(take 100 (sieve (iterate inc 2)))" "(take 20 (sieve (iterate inc 2)))" "(highest-prime-factor 600851475143)" "(highest-prime-factor 13195)" "board" "(def port (open \"/dev/ttyS42\"))" "(use 'serial-port)" "(def port (open \"/dev/ttyS42\"))" "(close 
                    #serial_port.Port{:path \"/dev/ttyS42\", :raw-port #<RXTXPort /dev/ttyS42>, :out-stream #<SerialOutputStream gnu.io.RXTXPort$SerialOutputStream@503ffcbe>, :in-stream #<SerialInputStream gnu.io.RXTXPort$SerialInputStream@3ce24a64>}
                    arduino-test.core> (def port (open \"/dev/ttyS42\"))
                    CompilerException java.lang.Exception: Sorry, couldn't connect to the port with path /dev/ttyS42, compiling:(form-init8377660112318395015.clj:1:11) )" "(close \"/dev/ttyS42\")" "(open \"/dev/ttyS42\")" "(def port (open \"/dev/ttyS42\"))" "(open \"/dev/ttyS42\")" "(open \"/dev/tty.usbmodemfa141\")" "(list-ports)" "(use 'serial-port)" "(:slot nil)" "(nil {})" "(nil nil)" "(count nil)" "(class nil)" "(class '())" "(:a '())" "(get-in '() [:a :b])" "(- (/ width 2) (/ cardwidth 2))" "(+ (/ width 2) (/ cardwidth 2))" "(draw-card 3 10 10)" "(draw-card lamo 10 10)" "(draw-card lamo)" "(draw-card \"ha\")" "(class \"hello\")" "(card-image {:number 11, :suit :bastos})" "(card-image {:number 11} {:suit :bastos})" "(in-ns 'truc-gui.core)" "(class cc1)" "(def cc1 (make-card 2 :espases))" "(in-ns 'truc-gui.deck)" "manilla-bona" "(rand 0.3)" "lamo" "(lamo)" "(in-ns 'truc-gui.core)" "(load-file \"src/truc_gui/core.clj\")" "(load-file \"src/truc-gui/core.clj\")" "(/ WIDTH 2)" "WIDTH" "(WIDTH)" "HEIGHT" "(in-ns 'truc-gui.core)" "([1 2 3] 0)" "([1 2 3] 1)" "(+ 2 -60)" "WIDTH" "(/ 2 WIDTH)" "(-main)" "(fight (make-card 10 :copas) (make-card 1 :bastos))" "(fight (make-card 1 :espases) (make-card 7 :espases))" "(fight (make-card 10 :bastos) (make-card 11 :oros))" "(fight (truc.deck/Card. 10 :bastos) (truc.deck/Card. 11 :oros))" "(fight (truc.deck/make-card 10 :bastos) (truc.deck/make-card. 11 :oros))" "(fight (make-card 10 :bastos) (make-card. 11 :oros))" "(fight (make-card 10 :bastos) (Card. 11 :oros))" "madona" "(fight (Card. 10 :bastos) (Card. 11 :oros))" "(-main)" "(get-round table)" "(get-round @table)" "@table" "@t" "(-main)" "(in-ns 'truc.core)" "(to-str-card nil)" "(in-ns 'truc.deck)" "(to-str-card nil)" "(-main)" "(show-table @table)" "(battle! table)" "(show-table @table)" "@table" "(auto-play-card! p2)" "(show-table @table)" "@table" "(play-card! p1)" "(get-winner @table)" "(deal-cards (shuffle deck))" "(reset-game!)" "(:slot @p1)" "(swap! table place-card :card1 c1)" "(:card1 @table)" "(get-round @table)" "@table" "(-main)" "(place-card (:slot @p1) c1 (empty-table))" "(:slot @p1)" "(:slot @player)" "c1" "(def c1 (peek-card 1 (:hand @p1)))" "(-main)" "(peek-card 1 (:hand @p1))" "(:hand @p1)" "(:hand @player)" "(-main)" "ll" "(def ll '(#truc.deck.Card{:number 7, :suit :bastos} #truc.deck.Card{:number 12, :suit :oros} #truc.deck.Card{:number 3, :suit :espases}))" "(Long. (read-line))" "(-main)" "(in-ns 'truc.core)" "(-main)" "(peek-card 0 [:c1 :c2 :c3])" "(peek-card 1 [:c1 :c2 :c3])" "(peek-card 0 [:c1 :c2 :c3])" "(in-ns 'truc.hand)" "(peek-card 0 [:c1 :c2 :c3])" "(< 4 3)" "(< 2 3)" "(-main)" "(drop-card (peek-card 1 [:c5 :c2 :c3]) [:c1 :c2 :c3])" "(drop-card (peek-card 1 [:c1 :c2 :c3]) [:c1 :c2 :c3])" "(peek-card 1 [:c1 :c2 :c3])" "(-main)" "(map #(ns-unmap *ns* %) (keys (ns-interns *ns*)))" "(-main)" "(ns-unmap *ns* 'core.deal)" "(ns-unmap *ns* 'core/deal)" "(-main)" "(ns-unmap *ns* 'deal)" "(ns-unmap *ns* deal)" "(ns-unmap **ns** deal)" "(-main)" "(in-ns 'truc.core)" "(fight (nth deck 6) (nth deck 8))" "(fight (nth deck 6) (nth deck 7))" "(fight (nth deck 6) (nth deck 5))" "(fight (nth deck 0) (nth deck 6))" "(fight (nth deck 0) (nth deck 5))" "(fight (nth deck 0) (nth deck 4))" "(fight (nth deck 0) (nth deck 3))" "(fight (nth deck 0) (nth deck 2))" "(fight (nth deck 0) (nth deck 1))" "(as? (nth deck 0))" "(nth deck 0)" "(as? (nth deck 0))" "(tres? (nth deck 0))" "(tres? (nth deck 1))" "(nth deck 2)" "(tres? (nth deck 2))" "(nth deck 6)" "(pessa? (nth deck 7))" "(pessa? (nth deck 6))" "(pessa? (nth deck 5))" "(pessa? (nth deck 16))" "(nth deck 16)" "(nth deck 15)" "(pessa? (nth deck 5))" "(nth deck 5)" "(nth deck 7)" "(get deck 7)" "(deck 7)" "(pessa? (Card. 11 :bastos))" "(pessa? {:number 11, :suite :bastos})" "(pessa? {:number 11, :suit :bastos})" "(Pessa? {:number 11, :suit :bastos})" "deck" "(in-ns 'truc.truc)" "(get-winner t1)" "(def t1 (->> t (write-winner :p1) (write-winner :p2) (write-winner :p2)))" "(get-winner t1)" "(def t1 (->> t (write-winner :p1) (write-winner :p2) (write-winner :p1)))" "(get-winner t)" "(get-winner t1)" "(def t1 (->> t (write-winner :p1) (write-winner :p2)))" "(get-winner t1)" "t1" "(def t1 (->> t (write-winner :p1) (write-winner :p1)))" "(write-winner :p1 t)" "(def t1 (->> empty-table (write-winner :p1) (write-winner :p1)))" "(def t1 (->> table (write-winner :p1) (write-winner :p1)))" "(place-card :card3 \"card\" t)" "(place-card :card1 \"card\" t)" "(place-card :card2 \"card\" t)" "(#{1 2 3} '(1 2))" "(#{1 2 3} 1)" "(place-card :card2 \"card\" t)" "(place-card :card1 \"card\" t)" "(def t (empty-table))" "(assoc (empty-table) :card1 1)" "(into {} empty-table)" "(assoc {} :card1 1)" "(assoc empty-table :card1 1)" "empty-table" "(place-card :card1 \"card\" t)" "(def t empty-table)" "(in-ns 'truc.table)" "(drop-card (peek-card 2 [:c1 :c2 :c3]) [:c1 :c2 :c3])" "(drop-card (peek-card 3 [:c1 :c2 :c3]) [:c1 :c2 :c3])" "(drop-card (peek-card 1 [:c1 :c2 :c3]) [:c1 :c2 :c3])" "(drop-card (peek-card 1 [:c1 :c2 :c3]) [:C1 :c2 :c3])" "(drop-card (peek-card 0 [:c1 :c2 :c3]) [:C1 :c2 :c3])" "(peek-card 0 [:c1 :c2 :c3])" "(peek-card 4 [:c1 :c2 :c3])" "(peek-card 3 [:c1 :c2 :c3])" "(peek-card 2 [:c1 :c2 :c3])" "(peek-card 1 [:c1 :c2 :c3])" "(peek-card 2 [:c1 :c2 :c3])" "(peek-card 1 [:c1 :c2 :c3])" "(in-ns 'truc.hand)" "(let [[a b :as l] '(1 2)] l)" "(let [[a b :as l] '(1 2)] b)" "(let [[a b] '(1 2)] b)" "(let [[a b] '(1 2)] a)" "(let [[a b] '('a 'b)] a)" "(->> spanish-deck (remove-numbers [2 8 9]))" "(shuffle spanish-deck)" "(deal 2 3 (shuffle (shuffle spanish-deck)))" "(deal 2 3 (shuffle spanish-deck))" "(deal 2 3 spanish-deck)" "(count (remove-numbers [2 8 9] spanish-deck))" "(count spanish-deck)" "(remove-numbers [2 8 9] spanish-deck)" "(-> spanish-deck (remove-numbers [2 8 9]))" "spanish-deck" "(in-ns 'truc.deck)" "(in-ns truc.deck)" "(get-winner {:winners [:p2 :p2]})" "(get-winner {:winners [:p1 :p1]})" "(get-winner {:winners [:p1 :p2 :p2]})" "(get-winner {:winners [:p1 :p2 :p1]})" "(get-winner {:winners [:p1 :p2]})" "(get-winner {:winners [:p1]})" "(get-winner {:winners []})" "(write-winner :p1 {:winners [:p2 :p2 :p1]})" "(write-winner :p1 {:winners [:p2 :p2]})" "(write-winner :p1 {:winners [:p2]})" "(write-winner :p1 {:winners [:p1]})" "(write-winner :p1 {:winners []})" "(write-winner {:winners :p1 []})" "(write-winner {:winners []})" "(get-winner {:winners [:p1 :p2 :p2]})" "(get-winner {:winners [:p1 :p2 :p1]})" "(get-winner {:winners [:p1 :p2]})" "(get-winner {:winners [:p1 :p1]})" "(get-winner {:winners []})" "(in-ns 'truc.table)" "(in-ns truc.table)" "(get-winner {:winners []})" "(let [#{p q} #{1 2}])" "(assoc {:a 2, :b 3} :b 4)" "b" "(b)" "(= b c)" "(def c (A. 1 2))" "(def b (A. 1 2))" "(defrecord A [a1 a2])" "(#{1} 1)" "(#{1} [1])" "(#{1} [1 2 3])" "(get [0 1 2 3] 4)" "(nth [0 1 2 3] 2 (println \"Not found!\"))" "(nth [0 1 2 3] 4 (println \"Not found!\"))" "(nth [0 1 2 3] 4 nil)" "(nth [0 1 2 3] 4)" "(nth [0 1 2 3] 1)" "(nth 1 [0 1 2 3])" "(defn a [] '())" "*ns*" "(in-ns 'stupidns)" "*ns*" "`+" "(some #{1 2 3 4} [2 5 6 7])" "(some #{1 2 3 4} [1 2 5 6 7])" "(some #{1 2 3 4} [1 5 6 7])" "(some #{1 2 3 4} [5 6 7])" "(some #{1 2 3 4} 1)" "1" "2" "5" "(-main)" "(show-winner game-won)" "(battle! table)" "@p2" "@p1" "(show-table table)" "(auto-play-card! p2)" "(play-card! p1)" "(show-table table)" "(battle! table)" "(show-table table)" "(auto-play-card! p2)" "(play-card! p1)" "@p2" "@p1" "(show-table table)" "(battle! table)" "(show-table table)" "(show-table)" "(auto-play-card! p2)" "(play-card! p1)" "(deal deck)" "(reset-game!)" "@p2" "@p1" "(deal deck)" "(show-table table)" "@table" "@game-won" "@p2" "@p1" "(-main)" "@game-won" "@table" "@p2" "@p1" "@game-won" "@table" "@p2" "@p1" "(reset-game!)" "@game-won" "@table" "@p2" "@p1" "@p" "(-main)" "@table" "(-main)" "(empty-table)" "@table" "@t1" "@p2" "@p1" "(-main)" "@game-won" "@table" "(-main)" "@game-won" "(-main)" "@table" "(-main)" "(round table)" "@table" "@game-won" "(reset! game-won (final-winner table))" "@game-won" "(not @game-won)" "(final-winner table)" "@table" "(-main)" "(fight (:card1 @table) (:card2 @table))" "(:card2 @table)" "(:card1 @table)" "(show-table table)" "(auto-play-card! p2)" "(play-card! p1)" "(show-table table)" "(-main)" "(show-table table)" "(battle! table)" "(show-table table)" "(auto-play-card! p2)" "(show-table table)" "(play-card! p1)" "(show-table table)" "(-main)" "(show-table table)" "(battle! table)" "(auto-play-card! p2)" "(-main)" "(place-card! (first (:hand @p2)) table)" "(first (:hand @p2))" "(:hand @p2)" "(winner table)" "(batt)" "@table" "(show-table table)" "(show-table)" "(show-cards p1)" "(-main)" "(play-card! p1)" "(play-card!)" "(place-card! \"2\" p1)" "(place-card! 2 p1)" "(-main)" "(class 0.1)" "(class .1)" "(class (Long. \"1\"))" "(class 1)" "(class (Integer. \"1\"))" "(Integer. \"1\")" "(.Integer \"1\")" "(read-line)" "(battle table)" "(show-table table)" "(place-card! 2 p2)" "(place-card! 1 p1)" "(place-card! 2 p1)")